\chapter{Description of existing \gls{SIDH} implementations}\label{chapter:existing_sidh}
Currently, three implementations of \gls{SIDH} are available: \textit{\gls{SIKE}} \parencite{sike2020spec} (closely related to \textit{\gls{PQCrypto-SIDH}} \parencite{microsoft2020sidh}), \textit{\gls{CIRCL}} \parencite{circl2020github} and \textit{SIKE for Java} \parencite{SikeForJava2020github}. In this chapter each implementation is introduced in detail. At the end of this chapter, \autoref{tab:existing_sidh} summarizes similarities and differences between all approaches.
\\
In the following, some algorithms are described as \textit{compressed}. These compressed version exploit shorter public key sizes while increasing the computation time of the algorithms.

\section{\gls{SIKE}}
\gls{SIKE} stands for \textbf{S}upersingular \textbf{I}sogeny \textbf{K}ey \textbf{E}ncapsulation. It is the reference implementation of the first proposed isogeny-based cryptographic primitives \parencite{jao2011towards}. Today, \gls{SIKE} is a \gls{NIST} candidate for quantum-resistant \textit{"Public-key Encryption and Key-establishment Algorithms"}. It is developed by a cooperation of researchers, lead by David Jao \parencite{sike2020spec}.
\subsubsection{SIKE vs. PQCrypto-SIDH}\label{existing:sike_vs_pqcrypto}
The \gls{SIKE} implementation is highly related to the \gls{SIDH} source code of Microsoft available on Github\footnote{https://github.com/microsoft/PQCrypto-SIDH}, called \gls{PQCrypto-SIDH}. At the beginning of this thesis both implementations were considered as different implementations. Since some researches of \gls{SIKE} also work for Microsoft the similarities of both APIs seemed to be reasonable. After contacting the \gls{SIKE} team due to compilation issues, David Jao stated that \gls{SIKE} uses the \textit{"[G]it repository hosted by Microsoft at
https://github.com/Microsoft/PQCrypto-SIDH [...] as the source
repository [...] to build the NIST package."} (personal communication, November 17, 2020). this circumstance is unfortunately not documented by \gls{SIKE}. At the same time the benchmark analysis between \gls{PQCrypto-SIDH} and \gls{SIKE} reveals performance differences between both implementations, which will be considered in the analysis taking place in \autoref{chapter:analysis}. However, since both libraries are closely related this thesis treats them as equal if not stated otherwise.
\\\\
\gls{SIKE} implements its key encapsulation mechanism (\gls{KEM}) upon a public key encryption system (\gls{PKE}) which is built upon \gls{SIDH} (as described in \autoref{chapter:background}). Besides a generic reference implementation, \gls{SIKE} offers various optimized implementations of their cryptographic primitves:
\begin{itemize}
  \item Generic optimized implementation, written in portable C
  \item x64 optimized implementation, partly written in x64 assembly
  \item x64 optimized compressed implementation, partly written in x64 assembly
  \item ARM64 optimized implementation, partly written in ARMv8 assembly
  \item ARM Cortex M4 optimized implementation, partly written in ARM thumb assembly
  \item VHDL implementation
\end{itemize}
All of these implementations can be run with the following parameter sets: \texttt{p434}, \texttt{p503}, \texttt{p610} and \texttt{p751}. \gls{SIKE} asserts to countermeasure timing and cache attacks by implementing constant time cryptography~\parencite{sike2020spec}.

\subsubsection{\gls{SIKE} API}
The API of \gls{SIKE} for a \gls{SIDH} key exchange is the following:

All parameters used in this API are of type \texttt{unsigned char*}. Note that for all implementations and all parameter sets the API is the same. Therefore, during compilation one need to include the correct subfolders (namely \texttt{SIKEp434}, \texttt{SIKEp503}, \texttt{SIKEp610} and \texttt{SIKEp751}) to initialize \gls{SIKE} with a specific parameter set.

\definecolor{keywordcol}{RGB}{51, 102, 255}
 \lstset{language=C, commentstyle=\color{Comment}\ttfamily, ,numbers=none, morekeywords={PrivateKey_A, PrivateKey_B, PublicKey_A, PublicKey_B, SharedSecret_A, SharedSecret_B}, keywordstyle=\color{keywordcol}, basicstyle=\small\ttfamily}

\begin{lstlisting}[]
// Generate random private key for Alice
void random_mod_order_A(PrivateKey_A);
\end{lstlisting}
Generating a random private key for Alice. The generated random bytes lie within an interval that is defined by the used parameter set. The generated private key is stored within \textcolor{keywordcol}{\texttt{PrivateKey}\_A}. No value is returned.\\

\begin{lstlisting}[]
// Generate random private key for Bob
void random_mod_order_B(PrivateKey_B);
\end{lstlisting}
Generating a random private key for Bob. The generated random bytes lie within an interval that is defined by the used parameter set. The generated private key is stored within \textcolor{keywordcol}{\texttt{PrivateKey}\_B}. No value is returned.\\

\begin{lstlisting}[]
// Generate ephemeral public key for Alice
int EphemeralKeyGeneration_A(PrivateKey_A, PublicKey_A);
\end{lstlisting}
This function takes Alice's randomly generated private key \textcolor{keywordcol}{\texttt{PrivateKey}\_A} as input and computes a corresponding public key in \textcolor{keywordcol}{\texttt{PublicKey}\_A}. The function returns 0 if successful.\\
The reference implementation of SIKE calls this function \texttt{isogen}. All later published SIKE implementations renamed the function to \texttt{EphemeralKeyGeneration}.\\

\begin{algorithmic}
\If {$i\geq maxval$}
    \State $i\gets 0$
\Else
    \If {$i+k\leq maxval$}
        \State $i\gets i+k$
    \EndIf
\EndIf
\end{algorithmic}

\begin{lstlisting}[]
// Generate ephemeral public key for Bob
int EphemeralKeyGeneration_B(PrivateKey_B, PublicKey_B);
\end{lstlisting}
This function takes Bob's randomly generated private key \textcolor{keywordcol}{\texttt{PrivateKey}\_B} as input and computes a corresponding public key in \textcolor{keywordcol}{\texttt{PublicKey}\_B}. The function returns 0 if successful.\\
The reference implementation of SIKE calls this function \texttt{isogen}. All later published SIKE implementations renamed the function to \texttt{EphemeralKeyGeneration}.\\

\begin{lstlisting}[]
// Computation of shared secret by Alice
int EphemeralSecretAgreement_A(PrivateKey_A, PublicKey_B, SharedSecret_A)
\end{lstlisting}
This function uses Alice's \textcolor{keywordcol}{\texttt{PrivateKey}\_A} and Bob's \textcolor{keywordcol}{\texttt{PublicKey}\_B} to produce a shared secret \textcolor{keywordcol}{\texttt{SharedSecret\_A}} between Alice and Bob. If successful, this function returns 0. 
Note that this is the same as the function \texttt{isoex} in the SIKE Reference implementation.\\

\begin{lstlisting}[]
// Computation of shared secret by Bob
int EphemeralSecretAgreement_B(PrivateKey_B, PublicKey_A, SharedSecret_B)
\end{lstlisting}
This function uses Bob's \textcolor{keywordcol}{\texttt{PrivateKey}\_B} and Alice's \textcolor{keywordcol}{\texttt{PublicKey}\_A} to produce a shared secret \textcolor{keywordcol}{\texttt{SharedSecret\_B}} between Alice and Bob. If successful, this function returns 0. 
Note that this is the same as the function \texttt{isoex} in the SIKE Reference implementation.


\section{\gls{CIRCL}}

\gls{CIRCL} (\textbf{C}loudflare \textbf{I}nteroperable, \textbf{R}eusable \textbf{C}ryptographic \textbf{L}ibrary) is a collection of cryptographic primitives developed by Cloudflare ~\parencite{circl2020github}. \gls{CIRCL} is written in Go and implements some quantum-secure algorithms like \gls{SIDH} and an isogeny-based \gls{KEM}. Note that the GO compiler outputs a native binary.  Cloudflare does not guarantee for any security within their library. Furthermore, the isogeny-based cryptographic primitives are adopted from the official \gls{SIKE} implementation. The following implementation optimizations are stated to be available:

\begin{itemize}
  \item Generic optimized implementation, written in Go 
  \item AMD64 optimized implementation, partly written in assembly
  \item ARM64 optimized implementation, partly written in assembly
\end{itemize}
Note that there are no compressed versions available. The library supports the following parameter sets: \texttt{p434}, \texttt{p503} and \texttt{p751}. To avoid side-channel attacks, their code is implemented in constant time~\parencite{circl2019intro}.

\subsubsection{\gls{CIRCL} API}
The API of \gls{CIRCL} for a \gls{SIDH} key exchange is the following:\\
(\texttt{XXX} $\in$ \{\texttt{434, 503, 751}\})


 \lstset{language=GO, commentstyle=\color{Comment}\ttfamily, ,numbers=none, morekeywords={PrivateKey_A, PrivateKey_B, PublicKey_A, PublicKey_B, SharedSecret_A, SharedSecret_B}, keywordstyle=\color{keywordcol}, tabsize=4, basicstyle=\small\ttfamily}

\begin{lstlisting}[]
// Generate random private key for Alice
PrivateKey_A = sidh.NewPrivateKey(sidh.FpXXX, sidh.KeyVariantSidhA)
PrivateKey_A.Generate(rand.Reader)

// Generate random private key for Bob
PrivateKey_B = sidh.NewPrivateKey(sidh.FpXXX, sidh.KeyVariantSidhB)
PrivateKey_B.Generate(rand.Reader)
\end{lstlisting}
The function \texttt{NewPrivateKey} allocates memory for a new private key using the defined parameter set (\texttt{sidh.FpXXX}) and the defined subject (\texttt{sidh.KeyVariantSidhA} for Alice and \texttt{sidh.KeyVariantSidhB} for Bob). The generated private key objects provides the function \texttt{Generate} that randomly generates a new private key based on a passed random number generator (\texttt{rand.Reader}) .
The code above initializes and randomly generates the private keys for Alice (\textcolor{keywordcol}{\texttt{PrivateKey\_A}}) and Bob (\textcolor{keywordcol}{\texttt{PrivateKey\_B}}).\\

\begin{lstlisting}[]
// Generate public key for Alice
PublicKey_A = sidh.NewPublicKey(sidh.FpXXX, sidh.KeyVariantSidhA)
PrivateKey_A.GeneratePublicKey(PublicKey_A)

// Generate public key for Bob
PublicKey_B = sidh.NewPublicKey(sidh.FpXXX, sidh.KeyVariantSidhB)
PrivateKey_B.GeneratePublicKey(PublicKey_B)
\end{lstlisting}
The function \texttt{NewPublicKey} allocates memory for a new public key using the defined parameter set (\texttt{sidh.FpXXX}) and the defined subject (\texttt{sidh.KeyVariantSidhA} for Alice and \texttt{sidh.KeyVariantSidhB} for Bob). The already generated private key object provides the function \texttt{GeneratePublicKey} that returns the appropriate public key into the passed public key object. This corresponds to the \texttt{isogen} function of the SIKE reference implementation.
The code above firstly initializes the public keys for Alice (\textcolor{keywordcol}{\texttt{PublicKey\_A}}) and Bob (\textcolor{keywordcol}{\texttt{PublicKey\_B}}). The above created private keys of Alice and Bob are then used to fill the public key objects.\\


\begin{lstlisting}[]
// Computation of shared secret by Alice
SharedSecret_A := make([]byte, PrivateKey_A.SharedSecretSize())
PrivateKey_A.DeriveSecret(SharedSecret_A, PublicKey_B)

// Computation of shared secret by Bob
SharedSecret_B := make([]byte, PrivateKey_B.SharedSecretSize())
PrivateKey_B.DeriveSecret(SharedSecret_B, PublicKey_A)
\end{lstlisting}
In order to create the shared secrets for Alice and Bob, the initially created private key objects provide the function \texttt{DeriveSecret}. This function expects a public key and a previously allocated memory to store the shared secret in. This corresponds to the \texttt{isoex} function of the SIKE reference implementation.
The code above firstly allocates the memory for a shared secret and finally generates the shared secret between Alice and Bob.

\section{SIKE for Java}
\textit{SIKE for Java} implements experimental supersingular isongeny cryptography in Java \parencite{SikeForJava2020github}. The library is developed by \textit{Wutra} in coooperation with \textit{Raiffeisen Bank International}. Besides a slow reference implementation which focuses on code readability, \textit{SIKE for Java} implements a optimized variant that focuses on performance and security. The library implements isogeny based \gls{PKE}, \gls{KEM} and \gls{SIDH} and supports the following parameter sets: \texttt{p434}, \texttt{p503}, \texttt{p610} and \texttt{p751}.\\
Since Java applications run via the Java Virtual Maschine (\gls{JVM})and are compiled during execution (Just-in-time compiler), the execution of Java programs is significantly slower than  executing C or GO programs, which compile the source code before the execution takes place (Ahead-of-time compiler). Thus, comparing SIDH implementations between Java and C/GO does not produce meaningful results. For that reason \textit{SIKE for Java} will not be considered for the benchmarks in this work.

\subsubsection{SIKE for Java API}

The API of \textit{SIKE for Java} for a \gls{SIDH} key exchange using the optimized implementation is the following:\\
(\texttt{XXX} $\in$ \{\texttt{434, 503, 610, 751}\})

 \lstset{language=Java, commentstyle=\color{Comment}\ttfamily, ,numbers=none, morekeywords={SikeParam, KeyGenerator, Sidh, KeyPair, Fp2Element}, keywordstyle=\color{keywordcol}, tabsize=4, basicstyle=\ttfamily}

\begin{lstlisting}[]
// Defining parameter set
SikeParam sikeParam = new SikeParamP434(ImplementationType.OPTIMIZED);

// Initializing key generator
KeyGenerator keyGenerator = new KeyGenerator(sikeParam);

// Prepare SIDH object
Sidh sidh = new Sidh(sikeParam);
\end{lstlisting}
First of all, the parameter set and the desired implementation is defined by creating a object \texttt{sikeParam} of type \texttt{SikeParam}. This object is used to initialize a \texttt{KeyGenerator} object (used to generate keys) and to initialize a \texttt{Sidh} object (used to compute the shared secret).\\

\begin{lstlisting}[]
// Initializing key pair for Alice
KeyPair keyPairA = keyGenerator.generateKeyPair(Party.ALICE);

// Initializing key pair for Bob
KeyPair keyPairB = keyGenerator.generateKeyPair(Party.BOB);
\end{lstlisting}
The object \texttt{keyGenerator} is used to generate key pairs for Alice and Bob by passing the appropriate party as parameter.\\

\begin{lstlisting}[]
// Computation of shared secret by Alice
Fp2Element secretA = sidh.generateSharedSecret(Party.ALICE,
													keyPairA.getPrivate(), 
													keyPairB.getPublic());

// Computation of shared secret by Bob
Fp2Element secretB = sidh.generateSharedSecret(Party.BOB, 
													keyPairB.getPrivate(), 
													keyPairA.getPublic());
\end{lstlisting}
In order to generate the shared secret between Alice and Bob, both need to call the \texttt{generateSharedSecret} function of the \texttt{sidh} object created above. Each party passes the own private key and the public key of the other party in order to compute the shared secret of type \texttt{Fp2Element}.

\section{Overview}

\begin{table}[H]
  \centering
  \begin{tabular}{|K{3cm}|K{4cm}|K{4cm}|K{4cm}|}
	\hline
    \rowcolor{lightgray!50}
     & \textbf{\gls{SIKE}} & \textbf{\gls{CIRCL}} & \textbf{SIKE for Java} \\
	\hline
    \bfseries\makecell{Developer}& Research cooperation & Cloudflare & Wultra \\
    \hline
    \bfseries\makecell{Language} & \makecell{C \\ Assembly} & \makecell{GO \\ Assembly} & Java \\
    \hline
    \bfseries\makecell{Reference} & \makecell{\url{www.sike.org}} & \makecell{Github:\\\href{https://github.com/cloudflare/circl}{cloudflare/circl}} & \makecell{Github:\\\href{https://github.com/wultra/sike-java}{wultra/sike-java}}\\
    \hline
    \hline
    \bfseries\makecell{Implemented \\ primitives} & \makecell{\gls{SIDH} \\ \gls{PKE} \\ \gls{KEM}\\} & \makecell{\gls{SIDH} \\ \gls{KEM}\\} & \makecell{\gls{SIDH} \\ \gls{PKE} \\ \gls{KEM}\\} \\
	\hline
	\bfseries\makecell{Available \\ parameters} & \makecell{p434 \\ p503 \\ p610 \\ p751\\} & \makecell{p434 \\ p503 \\ p751\\} & \makecell{p434 \\ p503 \\ p610 \\ p751\\} \\
	\hline
	\bfseries\makecell{Optimized \\ versions} & \makecell{Generic \\ Generic compressed \\ x64 \\ x64 compressed \\ ARM64 \\ ARM Cortex M4 \\ VHDL \\} & \makecell{Generic \\ AMD64\\ ARM64 \\} & \makecell{Generic for Java}\\
	\hline
	\bfseries\makecell{Security}  & \makecell{Constant time}  & \makecell{Constant time} & \makecell{Constant time} \\
	\hline
	\hline
	\bfseries\makecell{Considered for \\ benchmarking}  & \makecell{Yes (distinction to \\ \gls{PQCrypto-SIDH})}  & \makecell{Yes} & \makecell{No} \\
	\hline

  \end{tabular}
   \caption[Overview over existing \gls{SIDH} implementations]{Overview over existing \gls{SIDH} implementations.}\label{tab:existing_sidh}
\end{table}
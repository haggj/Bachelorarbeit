\chapter{Benchmarking Results}\label{chapter:analysis}

The results presented in this chapter were calculated on a x64 architecture (Intel(R) Core(TM) i5-6200U CPU @ 2.30GHz) running Ubuntu 20.04.1 LTS. The installed docker version was 19.03.8. The benchmarking suite was initialized to run callgrind and massif 100 times, respectively (e.g. N=100).\\
The exact values measured (averages and standard derivation over $N$=100 samples) and the identified execution hotspots for all implementations instantiated respectively with all parameter sets (see \autoref{sec:included_implementations}) can be found in addenda \ref{app:detailed_benchmarks}. The efficiency in this chapter will be quantified by the peak memory consumption and by the absolute instruction count measured by the benchmarking suite (details in \autoref{chapter:benchmarking_suite}). \\
The graphs presented use the following terminology:
Assume Alice (A) and Bob (B) want to establish a shared secret using a SIDH key exchange.
\begin{itemize}
\item \textit{KeygenA} describes the key generation (public and private key) of Alice.
\item \textit{KeygenB} describes the key generation (public and private key) of Bob.
\item \textit{SecretA} describes the computation of the shared secret by Alice.
\item \textit{SecretB} describes the computation of the shared secret by Bob.
\end{itemize}
This chapter starts with a comparison between all SIDH security levels in \autoref{sec:analysis_sidh_levels}. This demonstrates the performance differences of the available parameter sets. \\
A comparison among all presented SIDH libraries is given in \autoref{sec:analysis_sidh_libs}: Firstly, \ref{sec:analysis_sike} works out differences between \textit{compressed} and \textit{optimized} SIDH implementations. Then, all optimized variants (\textit{generic} and \textit{x64}) are compared in \ref{sec:analysis_optimized}. The compressed versions of all libraries are put into relation in \ref{sec:analysis_compressed}. Finally, a overview about the measured execution hotspots for all libraries is given in \ref{sec:analysis_sidh_hotspots}.\\
Differences in terms of efficiency between modern state-of-the-art ECDH and quantum-resistant SIDH are pointed out in \autoref{sec:analysis_effiency_ecdh}. This section also highlights execution hotspots measured for ECDH.\\
The chapter ends with security considerations for all benchmarked implementations in terms of constant time cryptography and key size (\autoref{sec:analysis_security}). 

\section{Comparing SIDH security levels}\label{sec:analysis_sidh_levels}

Before any differences between libraries or implementations are drawn, this section considers the different parameter sets proposed in \parencite{sike2020spec}: \texttt{p434}, \texttt{p503}, \texttt{p610} and \texttt{p751}. All these parameters match a security level defined by NIST (see \autoref{sidh_security} for details). This section makes use of the \texttt{SIKE\_x64} implementation to visualize the claimed resources of all parameter sets. However, the chosen implementation does not effect the results for this comparison .\\\\
\autoref{fig:results_all_curves} shows the absolute instruction counts for \texttt{SIKE\_x64} initialized with all available parameter sets. While \texttt{p434} executes 18 million instructions for \textit{KeygenA}, \texttt{p751} requires 67 million operations ($3.7$ times more). Roughly the same can be seen for \textit{KeygenB}, \textit{SecretA} and \textit{SecretB}. The other parameter sets \texttt{p503} and \texttt{p610} almost lie on a linear line between the highest and lowest security class.\\\\
Similarly, the measured peak memory consumption is for \texttt{p751} the highest ($13.3$ kB) and for \texttt{p434} the lowest ($8.2$ kB). Again, the other parameter sets can be found in between of these boundary values (\autoref{fig:results_all_curves_mem}). \\\\
This analysis clearly shows that a increased security level for SIDH corresponds with a increased claim of resources. While the difference in terms of memory consumption is relatively small the execution times differ a lot: On average and compared to \texttt{p434} the parameter set
\begin{itemize}
\itemsep0em 
\item \texttt{p503} executes $1.4$ times more instructions
\item \texttt{p610} executes $2.5$ times more instructions
\item \texttt{p710} executes $3.7$ times more instructions
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{benchmarks/all_curves/SIKE_x64}
  \caption[Overall instructions for all parameter sets via \texttt{SIKE\_x64}]
  {Overall instructions for \texttt{SIKE\_x64} initiated with all possible parameter sets.}
  \label{fig:results_all_curves}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{benchmarks/all_curves/SIKE_x64_mem}
  \caption[Maximum memory consumption for all parameter sets via \texttt{SIKE\_x64}]
  {Maximum memory consumption in kilobytes of \texttt{SIKE\_x64} initiated with all possible parameter sets.}
  \label{fig:results_all_curves_mem}
\end{figure}

\section{Comparing SIDH libraries}\label{sec:analysis_sidh_libs}

This section compares the following SIDH libraries: \textit{SIKE}, \textit{PQCrypto-SIDH} and \textit{CIRCL}. For a detailed description of these libraries see \autoref{chapter:existing_sidh}.

\subsection{Comparing SIKE Implementations}\label{sec:analysis_sike}
Before comparisons between the SIDH libraries \textit{SIKE}, \textit{PQ-Crypto} and \textit{CIRCL} are drawn, the performance differences between \textit{optimized} and \textit{compressed} versions are investigated. Exemplarily, all variants of SIKE are taken into considerations. Note that all \textit{compressed} versions of SIKE also contain \textit{optimized} code. Their key sizes, however, are reduced compared to non-compressed variants.
\\
\autoref{fig:results_sike} clearly shows a difference between \textit{optimized} and \textit{compressed} versions of SIKE in term of absolute instructions. Compressed versions roughly claim twice as much operations (\textasciitilde 500 million for \texttt{SIKE\_Generic\_Compressed} and \textasciitilde 45 million \texttt{SIKE\_x64\_Compressed}) to generate a key pair as non-compressed variants (\textasciitilde 200 million for \texttt{SIKE\_Generic} and \textasciitilde 19 million \texttt{SIKE\_x64}). Additionally, the generation of the shared secret is a little slower for the compressed implementations.\\
Besides execution times, \autoref{fig:results_sike_mem} also compares the memory consumption. As stated by the authors of SIKE, compressed variants allocate more memory: The peak memory allocation is with 17 kilobytes (\texttt{SIKE\_Generic\_Compressed}) and 19.2 kilobytes (\texttt{SIKE\_x64\_Compressed}) twice as high as the non-compressed versions.\\
The \texttt{SIKE\_Reference} implementation is with 11.2 kB allocated memory peak close to the average of all SIKE implementations. However, regarding the execution times for key generation, the reference implementation is by far the slowest variant: The more than 2.3 billion ($2.300.000.000$) instructions were measured in order to generate Bobs key pair. This is slower by factor 100 compared to \texttt{SIKE\_x64}. As the name suggests, this reference implementation must be seen as a proof-of-concept. Thus, it will not be considered further in this analysis.
\\\\
To sum up, the comparison between all SIKE implementations showed that \textit{optimized} versions have decreased instructions counts as well as decreased memory consumptions compared to \textit{compressed} implementations. The further analysis of the detailed benchmarks in in addenda \ref{app:detailed_benchmarks} lead to a very similar result for the \textit{PQ-Crypto} library of Microsoft.
One can state that \textit{compressed} versions roughly demand twice as much resources than \textit{optimized} variants.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{benchmarks/sike/sike}
  \caption[Overall instructions SIKE]
  {Overall instructions for all SIKE implementations initialized with \texttt{p434}. The reference implementation is the slowest, the x64 optimized version is the fastest. These results meet intuitive expectations.}
  \label{fig:results_sike}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{benchmarks/sike/sike_mem}
  \caption[Maximum memory consumption SIKE]
  {Maximum memory consumption in kilobytes or all SIKE implementations initialized with \texttt{p434}. The required memory overhead of compressed versions is clearly visible.}
  \label{fig:results_sike_mem}
\end{figure}

\subsection{Comparing optimized implementations}\label{sec:analysis_optimized}

\subsubsection{Generic optimized implementations}\label{sec:analysis_generic}
Generic optimized implementations contain generally optimized code for various hardware platforms. However, no hardware specific instructions can be exploited in these versions. The benchmarking suite currently supports \footnote{Although CIRCL states to offer a generic optimized implementation\parencite{circl2020github}, this version could not be compiled.}:
\begin{enumerate}
\item \textit{SIKE\_Generic}
\item \textit{Microsoft\_Generic}
\end{enumerate}
\autoref{fig:results_opt_434} shows the benchmarks for execution time of all optimized variants initiated with \texttt{p434}. For this section, however, only \textit{SIKE\_Generic} and \textit{Microsoft\_Generic} are taken into account. In all four steps of the SIDH key exchange the benchmarked values for both implementations look almost the same. However, when considering exact measurements from  \ref{app:detailed_benchmarks}, one can observe that \textit{SIKE\_Generic} executes constantly half a million operations less than \textit{Microsoft\_Generic} (this holds for all four categories: Keygen A, Keygen B, Secret A and Secret B). While this sounds significant, the relative difference is actually less than $0.01$\%. While the absolute gap further increases if higher security classes are analyzed (about three million operations constant difference for \texttt{p751}), the relative disparity stays smaller than $0.01$\%.
\\\\
Peak memory consumptions for parameter \textit{p434} are visualized in  \autoref{fig:results_opt_434_mem}. As in terms of execution time, memory allocation numbers between \textit{SIKE\_Generic} and \textit{Microsoft\_Generic} hardly differ: The SIKE version occupies $0.3$ kB less memory for \textit{p434} and $0.7$ kB less than for \textit{p751}. Overall, the relative difference regarding memory consumption is about $5$\%.
\\\\
Although both implementations hardly differ in their performance benchmarks one can state that \textit{SIKE\_Generic} demands less resources than \textit{Microsoft\_Generic}. This disparity, however, is marginal.

\subsubsection{x64 optimized implementations}\label{sec:analysis_x64}
X64 optimized implementations exploit AMD64 specific hardware operations to improve performance on these machines. The benchmarking suite currently supports the following x64 optimized variants:
\begin{enumerate}
\item \textit{SIKE\_x64}
\item \textit{Microsoft\_x64}
\item \textit{CIRCL\_x64}
\end{enumerate}
\autoref{fig:results_opt_434} shows the execution time benchmarks for all optimized variants initiated with \texttt{p434}. For this section, however, only \textit{SIKE\_x64}, \textit{Microsoft\_x64} and \textit{CIRCL\_x64} are taken into account. In all four categories listed in the graph \textit{Microsoft\_x64}  is the fastest implementation. \textit{SIKE\_x64} is slightly slower executing about two million instructions more in each category. This corresponds to a relative difference of about $10$\%. The most expensive implementation in terms of performed operations is \textit{CIRCL\_x64}: $40$\% more operations are needed in each step of the SIDH key exchange compared to the fastest variant \textit{Microsoft\_x64}.
\\
\autoref{fig:results_opt_751} compares the implementations initiated with \textit{p751} - matching the highest NIST security level 5. \textit{Microsoft\_x64} stays the fastest version while the realtive difference to \textit{SIKE\_x64} ($5$\%) and \textit{CIRCL\_x64} ($30$\%) decreases.
\\\\
To compare the memory consumption of the x64 optimized implementations, have a look at \autoref{fig:results_opt_434_mem}. The memory benchmarks of \textit{SIKE\_x64} ($8.2$ kB) and \textit{Microsoft\_x64} ($8.9$ kB) hardly differ, whereas \textit{CIRCL\_x64} has a peak allocation of $24.7$ kB for a single SIDH key exchange. This is by factor 2.5 greater compared to the others. However, \autoref{fig:results_opt_751_mem} reveals that the memory consumption for \textit{CIRCL\_x64} does barely change for higher security classes. Nevertheless,  \textit{CIRCL\_x64} has the most intense memory consumption of all x64 optimized implementations and \textit{Microsoft\_x64} allocates roughly about $10$\% more memory than \textit{SIKE\_x64} (this holds respectively for all security classes) .
\\\\
The fastest x64 optimized SIDH key exchange is performed by the Microsoft library \textit{PQ-Crypto}. \textit{SIKE\_x64} is slightly slower but allocates less memory than \textit{Microsoft\_x64}. The most resources are consumed by \textit{CIRCL\_x64} (instruction count and memory allocations).

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{benchmarks/optimized/434}
  \caption[Overall instructions p434]
  {Overall instructions for SIDH parameter \texttt{p434} compared to ECDH via \texttt{secp256r1}.}
  \label{fig:results_opt_434}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{benchmarks/optimized/434_mem}
  \caption[Maximum memory consumption p434]
  {Maximum memory consumption in kilobytes for SIDH parameter \texttt{p434} compared to ECDH via \texttt{secp256r1}.}
  \label{fig:results_opt_434_mem}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{benchmarks/optimized/751}
  \caption[Overall instructions p751]
  {Overall instructions for SIDH parameter \texttt{p751} compared to ECDH via \texttt{secp521r1}.}
  \label{fig:results_opt_751}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{benchmarks/optimized/751_mem}
  \caption[Maximum memory consumption 751]
  {Maximum memory consumption in kilobytes for SIDH parameter \texttt{p751} compared to ECDH via \texttt{secp521r1}.}
  \label{fig:results_opt_751_mem}
\end{figure}

\subsection{Comparing compressed implementations}\label{sec:analysis_compressed}
Compressed implementations of SIDH promise shortened key size compared to non-compressed versions, however, this leads to increased execution times and memory allocations. The benchmarking suite currently support the following compressed versions:
\begin{enumerate}
\item \textit{SIKE\_Generic\_Compressed}
\item \textit{SIKE\_x64\_Compressed}
\item \textit{Microsoft\_Generic\_Compressed}
\item \textit{Microsoft\_x64\_Compressed}
\end{enumerate}
\autoref{fig:results_comp_434} shows the execution time benchmarks for all compressed variants initiated with \texttt{p434}. Naturally, the x64 optimized code is faster than the generic optimization. The Microsoft implementations performed less operations than SIKE: Regarding key generation, \textit{SIKE\_Generic\_Compressed} performed on average $38$\% more instructions than \textit{Microsoft\_Generic\_Compressed} and \textit{SIKE\_x64\_Compressed} performed on average $45$\% more instructions than \textit{Microsoft\_x64\_Compressed}. The generation of the secret key only shows small differences between SIKE and Microsoft, however Microsoft is still the faster implementation. The trend of this analysis also applies for improved security classes, e.g for parameter \textit{p751} (see \autoref{fig:results_comp_751})
\\\\
The following evaluation of the allocated memory is surprising (\autoref{fig:results_comp_434_mem}): The Microsoft implementations occupy three times more memory than SIKE when initiated with \textit{p434}. This gap rises strongly when increasing the security class to \textit{p751} (\autoref{fig:results_comp_751_mem}), where the the \textit{PQ-Crypto} library of Microsoft allocates almost seven times more memory.
\\\\
While the benchmarks for the compressed Microsoft implementations show faster execution times, the overhead of allocated memory compared to SIKE is enormous.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{benchmarks/compressed/434}
  \caption[Overall instructions compressed p434]
  {Overall instructions for compressed SIDH parameter \texttt{p434}.}
  \label{fig:results_comp_434}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{benchmarks/compressed/434_mem}
  \caption[Maximum memory consumption compressed p434]
  {Maximum memory consumption in kilobytes for compressed SIDH parameter \texttt{p434}.}
  \label{fig:results_comp_434_mem}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{benchmarks/compressed/751}
  \caption[Overall instructions compressed p751]
  {Overall instructions for compressed SIDH parameter \texttt{p751}.}
  \label{fig:results_comp_751}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{benchmarks/compressed/751_mem}
  \caption[Maximum memory consumption compressed p751]
  {Maximum memory consumption in kilobytes for compressed SIDH parameter \texttt{p751}.}
  \label{fig:results_comp_751_mem}
\end{figure}

\subsection{Analysis of execution hotspots}\label{sec:analysis_sidh_hotspots}
Beside the detailed benchmarks addenda \ref{app:detailed_benchmarks} also lists the execution hotspots of each implementation initialized with different parameters. The following description of these hotspots reveals potential methods where performance of SIDH can be further improved.\\
This evaluation also shows the similarity of \textit{SIKE} and \textit{PQ-Crypto} which apparently build their SIDH APIs upon the same source code. Thus, both libraries suffer from the same execution hotspots: Each variant of \textit{SIKE} and \textit{PQ-Crypto} spends more than $50$\% of its execution time within the function \texttt{mp\_mul}. The second great hotspot of both libraries is the function \texttt{rdc\_mont} with up to $32$\% consumed operations:
\begin{enumerate}
\item \texttt{mp\_mul} calculates $c=a*b$ for two given n-digit integers $a$ and $b$ (based on Karatsubas multiplication algorithm).
\item \texttt{rdc\_mont} calculates $c = a\;mod\;p$ for given integers $a$ and $p$ (based on Montgomery reduction).
\end{enumerate}
The identified hotspots of \textit{CIRCL} are namely \texttt{mulPxxx} (\textasciitilde $50$\%) and \texttt{rdcPxxx} (\textasciitilde $50$\%) where \\\texttt{xxx} $\in \{434, 503, 751\}$. The source code provides further information, however, the documentation of \textit{CIRCL} makes it hard to do reliable statements on the exact internals of the identified hotspot functions:
\begin{enumerate}
\item \texttt{mulPxxx} calculates $z=x*y$ given integers $a$ and $b$ (based on Karatsubas multiplication algorithm).
\item \texttt{rdcPxxx} calculates $z = x*R^{-1} (mod 2*p)$ for given integers $x$ and $p$ (based on Montgomery reduction).
\end{enumerate}
It can be seen that all three SIDH libraries struggle with the same issue: Performing many multiplications and modulo operations is expensive. Since all libraries exploit state-of-the-art algorithms (Karatsubas multiplication algorithm and Montgomery reduction) the ongoing research in supersingular isogeny cryptography needs to find other ways to improve performance. Especially when comparing SIDH with modern ECDH key exchanges, these limitations are clearly visible.

\section{Comparing SIDH and ECDH} \label{sec:analysis_effiency_ecdh}

To be able to make reliable statements about the current state of SIDH this section compares the quantum-secure SIDH implementations with state-of-the-art elliptic curve Diffie-Hellman (ECDH). \\
Beside all optimized SIDH versions \autoref{fig:results_opt_434} also shows benchmarks for a ECDH reference value via \texttt{secp256r1}. Note that the security class of parameter set \texttt{p434} matches with \texttt{secp256r1} (see \autoref{sec:benchmarks_details} for details). Compared to the fastest SIDH optimized implementation (\texttt{Microsoft\_x64}) ECDH is significantly faster: $80$ times less instructions for KeygenA and $180$ times less instruction for KeygenB are executed. Additionally, the generation of the secret is $18$ times faster for secretA and $21$ times faster for secretB.\\
More moderate results can be observed for parameter set \texttt{P751} and \texttt{secp512} (\autoref{fig:results_opt_751}): KeygenA ($2.5$ times),  KeygenB ($3$ times), SecretA ($2.2$ times) and SecretB ($2.6$ times) of \texttt{secp512} are faster compared to the fastest SIDH variant \texttt{Microsoft\_x64}.
\\\\
While ECDH exploits much faster execution times the memory consumption of ECDH is higher.  \autoref{fig:results_opt_434_mem} shows a memory consumption of $7.7$ kB (\texttt{SIKE\_Generic} via \texttt{p434}) while ECDH allocates $12.2$ kB memory ($1.5$ times more). Similarly ECDH allocates $1.2$ times more memory than SIDH instantiated with \texttt{p751} (\autoref{fig:results_opt_751_mem}).
\\\\
In order to enable fast and user-friendly cryptography the execution times of cryptographic primitives are essential. ECDH of openssl requires less instructions than all SIDH libraries. While the difference for lower security classes is enormous, the comparison of higher security classes reveal less difference. However, the use of SIDH in a wide range of applications is currently hard to imagine. At the same time research is still ongoing and different optimizations for SIDH were proposed within the last years (see \url{https://sike.org/}). 
\subsection{Analysis of ECDH execution hotspots}

As listed in addenda \ref{app:detailed_benchmarks} the measured execution hotspots for the \textit{openssl} implementation of ECDH differ, since the \textit{openssl} implementation for \texttt{secp256r1} is \texttt{prime256v1} while \texttt{secp384r1} and \texttt{secp512r1} are directly implemented in the library~\parencite{turner2009elliptic}.\\
The hotspots of \texttt{secp256r1} are the low level prime field arithmetic functions \texttt{\_\_ecp\_nistz256\_mul\_montq} ($29.9$\%) and \texttt{\_\_ecp\_nistz256\_sqr\_montq} ($18.3$\%):
\begin{enumerate}
\item \texttt{\_\_ecp\_nistz256\_mul\_montq}\\Computation of a montgomery multiplication: $res = a*b*2^{-256}\;mod\;P$, for integers a, b and P.
\item \texttt{\_\_ecp\_nistz256\_sqr\_montq} \\Computation of a montgomery square: $res = a*a*2^{-256}\;mod\;P$, for integers a and P.
\end{enumerate}
The measured hotspots for the \texttt{secp384r1} and \texttt{secp512r1} are likewise prime field arithmetics: \texttt{bn\_mul\_mont} claims $67.2$\% (\texttt{secp384r1}) and $80.0$\% (\texttt{secp512r1}) of all executed instructions. \texttt{bn\_mod\_add\_fixed\_top} demands $6.2$\% (\texttt{secp384r1}) and $4.3$\% (\texttt{secp512r1}):
\begin{enumerate}
\item \texttt{bn\_mul\_mont}\\Computation of a montgomery multiplication for \textit{bignum} integers.
\item \texttt{bn\_mod\_add\_fixed\_top}\\\textit{"\texttt{BN\_mod\_add} variant that may be used if both a and b are non-negative and less than m."}
\end{enumerate}
Similar to the previously described SIDH hotspots the underlying performance bottlenecks of ECDH are related to prime field arithmetic. The well researched ECDH cryptography enables similar  algorithms (montgomery multiplication) in order to speed up cryptographic primitives. This results in fast and user-friendly encryption schemes.
\section{Security Considerations}\label{sec:analysis_security}

In order to analyze the given implementations in terms of security, the claim of all libraries to implement security relevant functions in constant time is investigated in \autoref{sec:analysis_security_time}. The implemented key sizes of all SIDH libraries and the used ECDH curves will be considered additionally in \autoref{sec:analysis_security_keys}.

\subsection{Constant time}\label{sec:analysis_security_time}
Beside the average for $N=100$ executions ($\bar{x}=\frac{1}{N}\sum_{i=1}^N{(x_i})$ addenda \ref{app:detailed_benchmarks} also lists the standard deviation of the measured execution time and allocated memory. This standard deviation is computed as $s=\sqrt{\frac{1}{N-1}\sum_{i=1}^N(x_i-\bar{x})^2}$. In this section the measured standard deviations are considered to verify if the libraries implement constant time cryptography.\\
Since the performed public key compression of each \textit{compressed} variant of SIDH depends on the public key itself (rather than on the public key size), they are not implemented in constant time. This is directly visible from  addenda \ref{app:detailed_benchmarks}.\\\\
On the other hand, the standard deviation for the following variants is zero and thus these variants implement constant time cryptography:
\begin{itemize}
\item \texttt{SIKE\_Reference}, \texttt{SIKE\_Generic} and \texttt{SIKE\_x64}
\item \texttt{Microsoft\_Generic} and \texttt{Microsoft\_x64}
\end{itemize}
The following implementations show deviations in their execution time. Thus, they are not implemented in constant time:

\begin{itemize}
\item \texttt{ECDH} for the benchmarked curves \texttt{secp256r1},  \texttt{secp384r1},\texttt{secp512r1} in \textit{openssl}
\item \texttt{CIRCL\_x64}
\end{itemize}

\subsection{Key size}\label{sec:analysis_security_keys}

This section compares the size of public keys implemented by the SIDH libraries \textit{SIKE}, \textit{PQ-Crypto} and \textit{CIRCL} with modern \textit{openssl} ECDH. The used parameters matching the appropriate NIST security level can be found in \autoref{sec:benchmarks_details}. Since all SIDH libraries implement the same parameter sets their key sizes are identical. However, \textit{compressed} variants of SIDH benefit from reduced public key sizes, while extending execution time. The key sizes of the used ECDH curves is part of the name, e.g. \texttt{secp256r1} exploits 256 bits (256/8 = 32 bytes) as public key. The following table lists the relevant key sizes in bytes:
\begin{table}[H]
	\centering
	\begin{tabular}{|K{2.5cm}|K{2.5cm}|K{2.5cm}|K{2.5cm}|K{2.5cm}|}
	\hline
	\rowcolor{lightgray!50}
	\bfseries\makecell{Algorithm} & \bfseries\makecell{SIDH} & \bfseries\makecell{SIDH \\ compressed} & \bfseries\makecell{ECDH} \\
	\hline
	\makecell{NIST level 1} & \makecell{330} & \makecell{197} & \makecell{256/8 = 32} \\
	\hline
	\makecell{NIST level 2} & \makecell{378} & \makecell{225} & \makecell{384/8 = 48}\\
	\hline
	\makecell{NIST level 3} & \makecell{462} & \makecell{274} & \makecell{-} \\
	\hline
	\makecell{NIST level 5} & \makecell{564} & \makecell{335} & \makecell{521/8 $\approx$ 65}\\
	\hline
	\end{tabular}
	\caption[Comparison of key sizes]{Comparison of key sizes in bytes}
	\label{tab:benchmarks_Sike_x64}
\end{table}
Shorter public key sizes reduce transmitting and storage costs. The ECDH implementations exploit significantly shorter public keys than SIDH. However, SIDH implements the shortest public key sizes of all quantum-resistant alternatives \parencite{koziel2018high}.
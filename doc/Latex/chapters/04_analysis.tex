\chapter{Performance Analysis}\label{chapter:analysis}

This chapter analyses the results presented in \autoref{sec:benchmarks_results}. First of all the efficiency in terms of memory consumption and execution runtime is investigated (\autoref{sec:analysis_effiency}). The security of the benchmarked libraries will be evaluated in \autoref{sec:analysis_security}. 

\section{Measures for Efficiency}\label{sec:analysis_effiency}

The efficiency of SIDH libraries will be quantified by the peak memory consumption and by the absolute instruction count. These measures are benchmarked for all implemented parameter sets of a given implementation (for details see \autoref{chapter:benchmarks}).\\ 
\hyperref[sec:analysis_effiency_sidh]{Subsection~\ref*{sec:analysis_sidh_levels}} firstly compares the performance of all SIDH security levels. Next, all
SIDH libraries are compared (\autoref{sec:analysis_effiency_sidh}) before modern key exchange primitives (namely ECDH) are taken into account in \autoref{sec:analysis_effiency_ecdh}.

\section{Comparing SIDH security levels}\label{sec:analysis_sidh_levels}

\section{Comparing SIKE Implementations}\label{sec:analysis_sike}
Before comparisons between the SIDH libraries \textit{SIKE}, \textit{PQ-Crypto} and \textit{CIRCL} are drawn, the performance differences between \textit{optimized} and \textit{compressed} versions are investigated. Exemplarily, all variants of SIKE are taken into considerations. Note that all \textit{compressed} versions of SIKE also contain \textit{optimized} code. Their key sizes, however, are reduced compared to non-compressed variants.
\\
\autoref{fig:results_sike} clearly shows a difference between \textit{optimized} and \textit{compressed} versions of SIKE in term of absolute instructions. Compressed versions roughly claim twice as much operations (\textasciitilde 500 million for \texttt{SIKE\_Generic\_Compressed} and \textasciitilde 45 million \texttt{SIKE\_x64\_Compressed}) to generate a key pair as non-compressed variants (\textasciitilde 200 million for \texttt{SIKE\_Generic} and \textasciitilde 19 million \texttt{SIKE\_x64}). Additionally, the generation of the shared secret is a little slower for the compressed implementations.\\
Besides execution times, \autoref{fig:results_sike_mem} also compares the memory consumption. As stated by the authors of SIKE, compressed variants allocate more memory: The peak memory allocation is with 17 kilobytes (\texttt{SIKE\_Generic\_Compressed}) and 19.2 kilobytes (\texttt{SIKE\_x64\_Compressed}) twice as high as the non-compressed versions.\\
The \texttt{SIKE\_Reference} implementation is with 11.2 kB allocated memory peak close to the average of all SIKE implementations. However, regarding the execution times for key generation, the reference implementation is by far the slowest variant: The more than 2.3 billion ($2.300.000.000$) instructions were measured in order to generate Bobs key pair. This is slower by factor 100 compared to \texttt{SIKE\_x64}. As the name suggests, this reference implementation must be seen as a proof-of-concept. Thus, it will not be considered further in this analysis.
\\\\
To sum up, the comparison between all SIKE implementations showed, that \textit{optimized} versions have decreased instructions counts as well as decreased memory consumptions compared to \textit{compressed} implementations. The further analysis of the detailed benchmarks in in addenda \ref{app:detailed_benchmarks} lead to a very similar result for the \textit{PQ-Crypto} library of Microsoft.
One can state, that \textit{compressed} versions roughly demand twice as much resources than \textit{optimized} variants.

\section{Comparing optimized implementations}

\subsection{Generic optimized implementations}
Generic optimized implementations contain generally optimized code for various hardware platforms. However, no hardware specific instructions can be exploited in these versions. The benchmarking suite currently supports \footnote{Although CIRCL states to offer a generic optimized implementation\parencite{circl2020github}, this version could not be compiled.}:
\begin{enumerate}
\item \textit{SIKE\_Generic}
\item \textit{Microsoft\_Generic}
\end{enumerate}
\autoref{fig:results_opt_434} shows the benchmarks for execution time of all optimized variants initiated with \texttt{p434}. For this section, however, only \textit{SIKE\_Generic} and \textit{Microsoft\_Generic} are taken into account. In all four steps of the SIDH key exchange the benchmarked values for both implementations look almost the same. However, when considering exact measurements from  \ref{app:detailed_benchmarks}, one can observe that \textit{SIKE\_Generic} executes constantly half a million operations less than \textit{Microsoft\_Generic} (this holds for all four categories: Keygen A, Keygen B, Secret A and Secret B). While this sounds significant, the relative difference is actually less than $0.01$\%. While the absolute gap further increases if higher security classes are analyzed (about three million operations constant difference for \texttt{p751}), the relative disparity stays smaller than $0.01$\%.
\\\\
Peak memory consumptions for parameter \textit{p434} are visualized in  \autoref{fig:results_opt_434_mem}. As in terms of execution time, memory allocation numbers between \textit{SIKE\_Generic} and \textit{Microsoft\_Generic} hardly differ: The SIKE version occupies $0.3$ kB less memory for \textit{p434} and $0.7$ kB less than for \textit{p751}. Overall, the relative difference regarding memory consumption is about $5$\%.
\\\\
Although both implementations hardly differ in their performance benchmarks one can state, that \textit{SIKE\_Generic} demands less resources than \textit{Microsoft\_Generic}. This disparity, however, is marginal.

\subsection{x64 optimized implementations}
X64 optimized implementations exploit AMD64 specific hardware operations to improve performance on these machines. The benchmarking suite currently supports the following x64 optimized variants:
\begin{enumerate}
\item \textit{SIKE\_x64}
\item \textit{Microsoft\_x64}
\item \textit{CIRCL\_x64}
\end{enumerate}
\autoref{fig:results_opt_434} shows the execution time benchmarks for all optimized variants initiated with \texttt{p434}. For this section, however, only \textit{SIKE\_x64}, \textit{Microsoft\_x64} and \textit{CIRCL\_x64} are taken into account. In all four categories listed in the graph \textit{Microsoft\_x64}  is the fastest implementation. \textit{SIKE\_x64} is slightly slower executing about two million instructions more in each category. This corresponds to a relative difference of about $10$\%. The most expensive implementation in terms of performed operations is \textit{CIRCL\_x64}: $40$\% more operations are needed in each step of the SIDH key exchange compared to the fastest variant \textit{Microsoft\_x64}.
\\
\autoref{fig:results_opt_751} compares the implementations initiated with \textit{p751} - matching the highest NIST security level 5. \textit{Microsoft\_x64} stays the fastest version while the realtive difference to \textit{SIKE\_x64} ($5$\%) and \textit{CIRCL\_x64} ($30$\%) decreases.
\\\\
To compare the memory consumption of the x64 optimized implementations, have a look at \autoref{fig:results_opt_434_mem}. The memory benchmarks of \textit{SIKE\_x64} ($8.2$ kB) and \textit{Microsoft\_x64} ($8.9$ kB) hardly differ, whereas \textit{CIRCL\_x64} has a peak allocation of $24.7$ kB for a single SIDH key exchange. This is by factor 2.5 greater compared to the others. However, \autoref{fig:results_opt_751_mem} reveals that the memory consumption for \textit{CIRCL\_x64} does barely change for higher security classes. Nevertheless,  \textit{CIRCL\_x64} has the most intense memory consumption of all x64 optimized implementations and \textit{Microsoft\_x64} allocates roughly about $10$\% more memory than \textit{SIKE\_x64} (this holds respectively for all security classes) .
\\\\
The fastest x64 optimized SIDH key exchange is performed by the Microsoft library \textit{PQ-Crypto}. \textit{SIKE\_x64} is slightly slower but allocates less memory than \textit{Microsoft\_x64}. The most resources are consumed by \textit{CIRCL\_x64} (instruction count and memory allocations).

\section{Comparing compressed implementations}
Compressed implementations of SIDH promise shortened key size compared to non-compressed versions, however, this leads to increased execution times and memory allocations. The benchmarking suite currently support the following compressed versions:
\begin{enumerate}
\item \textit{SIKE\_Generic\_Compressed}
\item \textit{SIKE\_x64\_Compressed}
\item \textit{Microsoft\_Generic\_Compressed}
\item \textit{Microsoft\_x64\_Compressed}
\end{enumerate}
\autoref{fig:results_comp_434} shows the execution time benchmarks for all compressed variants initiated with \texttt{p434}. Naturally, the x64 optimized code is faster than the generic optimization. The Microsoft implementations performed less operations than SIKE: Regarding key generation, \textit{SIKE\_Generic\_Compressed} performed on average $38$\% more instructions than \textit{Microsoft\_Generic\_Compressed} and \textit{SIKE\_x64\_Compressed} performed on average $45$\% more instructions than \textit{Microsoft\_x64\_Compressed}. The generation of the secret key only shows small differences between SIKE and Microsoft, however Microsoft is still the faster implementation. The trend of this analysis also applies for improved security classes, e.g for parameter \textit{p751} (see \autoref{fig:results_comp_751})
\\\\
The following evaluation of the allocated memory is surprising (\autoref{fig:results_comp_434_mem}): The Microsoft implementations occupy three times more memory than SIKE when initiated with \textit{p434}. This gap rises strongly when increasing the security class to \textit{p751} (\autoref{fig:results_comp_751_mem}), where the the \textit{PQ-Crypto} library of Microsoft allocates almost seven times more memory.
\\\\
While the benchmarks for the compressed Microsoft implementations show faster execution times, the overhead of allocated memory compared to SIKE is enormous.
\section{Analysis of execution hotspots}
Beside the detailed benchmarks addenda \ref{app:detailed_benchmarks} also lists the execution hotspots of each implementation initialized with different parameters. The following description of these hotspots reveals potential methods where performance of SIDH can be further improved.\\
This evaluation also shows the similarity of \textit{SIKE} and \textit{PQ-Crypto} which apparently build their SIDH APIs upon the same source code. Thus, both libraries suffer from the same execution hotspots: Each variant of \textit{SIKE} and \textit{PQ-Crypto} spends more than $50$\% of its execution time within the function \texttt{mp\_mul}. The second great hotspot of both libraries is the function \texttt{rdc\_mont} with up to $32$\% consumed operations:
\begin{enumerate}
\item \texttt{mp\_mul} calculates $c=a*b$ for two given n-digit integers $a$ and $b$ (based on Karatsubas multiplication algorithm).
\item \texttt{rdc\_mont} calculates $c = a\;mod\;p$ for given integers $a$ and $p$ (based on Montgomery reduction).
\end{enumerate}
The identified hotspots of \textit{CIRCL} are namely \texttt{mulPxxx} (\textasciitilde $50$\%) and \texttt{rdcPxxx} (\textasciitilde $50$\%) where \\\texttt{xxx} $\in \{434, 503, 751\}$. The source code provides further information, however, the documentation of \textit{CIRCL} makes it hard to do reliable statements on the exact internals of the identified hotspot functions:
\begin{enumerate}
\item \texttt{mulPxxx} calculates $z=x*y$ given integers $a$ and $b$ (based on Karatsubas multiplication algorithm).
\item \texttt{rdcPxxx} calculates $z = x*R^{-1} (mod 2*p)$ for given integers $x$ and $p$ (based on Montgomery reduction).
\end{enumerate}
It can be seen that all three SIDH libraries struggle with the same issue: Performing many multiplications and modulo operations is expensive. Since all libraries exploit state-of-the-art algorithms (Karatsubas multiplication algorithm and Montgomery reduction) the ongoing research in supersingular isogeny cryptography needs to find other ways to improve performance. Especially when comparing SIDH with modern ECDH key exchanges, these limitations are clearly visible.

\section{Comparing SIDH and ECDH} \label{sec:analysis_effiency_ecdh}

To be able to make reliable statements about the current state of SIDH this section compares the quantum-secure SIDH implementations with state-of-the-art elliptic curve Diffie-Hellman (ECDH). \\
Beside all optimized SIDH versions \autoref{fig:results_opt_434} also shows benchmarks for a ECDH reference value via \texttt{secp256r1}. Note, that the security class of parameter set \texttt{p434} matches with \texttt{secp256r1} (see \autoref{sec:benchmarks_details} for details). Compared to the fastest SIDH optimized implementation (\texttt{Microsoft\_x64}) ECDH is significantly faster: $80$ times less instructions for KeygenA and $180$ times less instruction for KeygenB are executed. Additionally, the generation of the secret is $18$ times faster for secretA and $21$ times faster for secretB.\\
More moderate results can be observed for parameter set \texttt{P751} and \texttt{secp512} (\autoref{fig:results_opt_751}): KeygenA ($2.5$ times),  KeygenB ($3$ times), SecretA ($2.2$ times) and SecretB ($2.6$ times) of \texttt{secp512} are faster compared to the fastest SIDH variant \texttt{Microsoft\_x64}.
\\\\
While ECDH exploits much faster execution times the memory consumption of ECDH is higher.  \autoref{fig:results_opt_434_mem} shows a memory consumption of $7.7$ kB (\texttt{SIKE\_Generic} via \texttt{p434}) while ECDH allocates $12.2$ kB memory ($1.5$ times more). Similarly ECDH allocates $1.2$ times more memory than SIDH instantiated with \texttt{p751} (\autoref{fig:results_opt_751_mem}).
\\\\
In order to enable fast and user-friendly cryptography the execution times of cryptographic primitives are essential. ECDH of openssl requires less instructions than all SIDH libraries. While the difference for lower security classes is enormous, the comparison of higher security classes reveal less difference. However, the use of SIDH in a wide range of applications is currently hard to imagine. At the same time research is still ongoing and different optimizations for SIDH were proposed within the last years (see \url{https://sike.org/}). 
\subsection{Analysis of ECDH execution hotspots}

As listed in addenda \ref{app:detailed_benchmarks} the measured execution hotspots for the \textit{openssl} implementation of ECDH differ, since the \textit{openssl} implementation for \texttt{secp256r1} is \texttt{prime256v1} while \texttt{secp384r1} and \texttt{secp512r1} are directly implemented in the library~\parencite{turner2009elliptic}.\\
The hotspots of \texttt{secp256r1} are the low level prime field arithmetic functions \texttt{\_\_ecp\_nistz256\_mul\_montq} ($29.9$\%) and \texttt{\_\_ecp\_nistz256\_sqr\_montq} ($18.3$\%):
\begin{enumerate}
\item \texttt{\_\_ecp\_nistz256\_mul\_montq}\\Computation of a montgomery multiplication: $res = a*b*2^{-256}\;mod\;P$, for integers a, b and P.
\item \texttt{\_\_ecp\_nistz256\_sqr\_montq} \\Computation of a montgomery square: $res = a*a*2^{-256}\;mod\;P$, for integers a and P.
\end{enumerate}
The measured hotspots for the \texttt{secp384r1} and \texttt{secp512r1} are likewise prime field arithmetics: \texttt{bn\_mul\_mont} claims $67.2$\% (\texttt{secp384r1}) and $80.0$\% (\texttt{secp512r1}) of all executed instructions. \texttt{bn\_mod\_add\_fixed\_top} demands $6.2$\% (\texttt{secp384r1}) and $4.3$\% (\texttt{secp512r1}):
\begin{enumerate}
\item \texttt{bn\_mul\_mont}\\Computation of a montgomery multiplication for \textit{bignum} integers.
\item \texttt{bn\_mod\_add\_fixed\_top}\\\textit{"\texttt{BN\_mod\_add} variant that may be used if both a and b are non-negative and less than m."}
\end{enumerate}
Similar to the previously described SIDH hotspots the underlying performance bottlenecks of ECDH are related to prime field arithmetic. The well researched ECDH cryptography enables similar  algorithms (montgomery multiplication) in order to speed up cryptographic primitives. This results in fast and user-friendly encryption schemes.
\section{Security Considerations}\label{sec:analysis_security}

In order to analyze the given implementations in terms of security, the claim of all libraries to implement security relevant functions in constant time is investigated in \autoref{sec:analysis_security_time}. The implemented key sizes of all SIDH libraries and the used ECDH curves will be considered additionally in \autoref{sec:analysis_security_keys}.

\subsection{Constant time}\label{sec:analysis_security_time}
Beside the average for $N=100$ executions ($\bar{x}=\frac{1}{N}\sum_{i=1}^N{(x_i})$ addenda \ref{app:detailed_benchmarks} also lists the standard deviation of the measured execution time and allocated memory. This standard deviation is computed as $s=\sqrt{\frac{1}{N-1}\sum_{i=1}^N(x_i-\bar{x})^2}$. In this section the measured standard deviations are considered to verify if the libraries implement constant time cryptography.\\
Since the performed public key compression of each \textit{compressed} variant of SIDH depends on the public key itself (rather than on the public key size), they are not implemented in constant time. This is directly visible from  addenda \ref{app:detailed_benchmarks}.\\\\
On the other hand, the standard deviation for the following variants is zero and thus these variants implement constant time cryptography:
\begin{itemize}
\item \texttt{SIKE\_Reference}, \texttt{SIKE\_Generic} and \texttt{SIKE\_x64}
\item \texttt{Microsoft\_Generic} and \texttt{Microsoft\_x64}
\end{itemize}
The following implementations show deviations in their execution time. Thus, they are not implemented in constant time:

\begin{itemize}
\item \texttt{ECDH} for the benchmarked curves \texttt{secp256r1},  \texttt{secp384r1},\texttt{secp512r1} in \textit{openssl}
\item \texttt{CIRCL\_x64}
\end{itemize}

\subsection{Key size}\label{sec:analysis_security_keys}

This section compares the size of public keys implemented by the SIDH libraries \textit{SIKE}, \textit{PQ-Crypto} and \textit{CIRCL} with modern \textit{openssl} ECDH. The used parameters matching the appropriate NIST security level can be found in \autoref{sec:benchmarks_details}. Since all SIDH libraries implement the same parameter sets their key sizes are identical. However, \textit{compressed} variants of SIDH benefit from reduced public key sizes, while extending execution time. The key sizes of the used ECDH curves is part of the name, e.g. \texttt{secp256r1} exploits 256 bits (256/8 = 32 bytes) as public key. The following table lists the relevant key sizes in bytes:
\begin{table}[H]
	\centering
	\begin{tabular}{|K{2.5cm}|K{2.5cm}|K{2.5cm}|K{2.5cm}|K{2.5cm}|}
	\hline
	\rowcolor{lightgray!50}
	\bfseries\makecell{Algorithm} & \bfseries\makecell{SIDH} & \bfseries\makecell{SIDH \\ compressed} & \bfseries\makecell{ECDH} \\
	\hline
	\makecell{NIST level 1} & \makecell{330} & \makecell{197} & \makecell{256/8 = 32} \\
	\hline
	\makecell{NIST level 2} & \makecell{378} & \makecell{225} & \makecell{384/8 = 48}\\
	\hline
	\makecell{NIST level 3} & \makecell{462} & \makecell{274} & \makecell{-} \\
	\hline
	\makecell{NIST level 5} & \makecell{564} & \makecell{335} & \makecell{521/8 $\approx$ 65}\\
	\hline
	\end{tabular}
	\caption[Comparison of key sizes]{Comparison of key sizes in bytes}
	\label{tab:benchmarks_Sike_x64}
\end{table}
Shorter public key sizes reduce transmitting and storage costs. The ECDH implementations exploit significantly shorter public keys than SIDH. However, SIDH implements the shortest public key sizes of all quantum-resistant alternatives \parencite{koziel2018high}.

%CIRCL:
%434 -> 330 bytes
%503 -> 378 bytes
%751 -> 564 bytes

%MS:
%default:
%434 -> 330 bytes
%503 -> 378 bytes
%610 -> 462 bytes
%751 -> 564 bytes
%compressed:
%434 -> 197 bytes
%503 -> 225 bytes
%610 -> 274 bytes
%751 -> 335 bytes